import r2pipe
import json
from os import path
from binascii import hexlify,unhexlify
import csv
from sys import exit, exc_info
from time import sleep
from sys import argv
from os import makedirs

curr_dir = path.dirname(path.abspath(__file__))
curr_dir += "\\"

Dll_filename = argv[1]
pdb_filename = argv[2]
func_list_filename = argv[3]
funcList_file_name = curr_dir + func_list_filename
Dll_path = curr_dir + Dll_filename
pdb_path = curr_dir + pdb_filename
output_dir = curr_dir + "output\\"
try:
    makedirs(output_dir)
except FileExistsError:
    pass

def file_dump(file_name,dump_string):
    """ Dumps an object in write char mode. """
    file_1 = open(output_dir+file_name+".txt","w")
    file_1.write(dump_string)
    file_1.close()

def file_hex_dump(file_name,dump_string):
    """ Dumps an object in binary form. """
    file_1 = open(output_dir+file_name+".txt","wb")
    file_1.write(dump_string)
    file_1.close()

def find_hex(file_path,dump_string):
    """ Find hex dump inside dll and return offeset with respect to dll. """
    file_1 = open(file_path,"rb")
    file_data = file_1.read()
    string_loc = file_data.find(dump_string)
    return string_loc

def get_mangled_name(is_class, class_name, method_name):
    """ Form the C++ mangled name using class name and function name. """
    fn_name_mangled = ""
    if is_class:
        # fn_name_mangled = "_thiscall_" + class_name + "::" + method_name
        fn_name_mangled = class_name + "::" + method_name
    else:
        # fn_name_mangled = "_cdecl_" + method_name
        fn_name_mangled = method_name
    return fn_name_mangled

def get_func_list_from_afl(r2_dbg_dataobj,class_name,method_name):
    """ 
    Use afl functions json database to form list of functions matching
    the required class name and function name. Used to find exported functions.
    The found function name should start with "sym." to indicate it to be a symbol.
    """
    func_list = []
    is_class = True
    if (class_name=="") : is_class=False
    fn_mangled_name = get_mangled_name(is_class, class_name, method_name)
    print("Fn Mangled name:",fn_mangled_name)
    for func_inst in r2_dbg_dataobj:
        temp_var = func_inst["name"]
        if ((temp_var.startswith("sym.")) and (temp_var.find(fn_mangled_name) > 0)):
            func_list.append(temp_var)
    return func_list

def get_func_list_from_flaglist(r2_dbg_flagsobj,class_name,method_name):
    """ 
    Use flags json database to form list of functions matching
    the required class name and function name. Used to find unexported functions.
    The found function name should start with "pdb." to indicate it to be a flag from debug info.
    """
    func_list = []
    is_class = True
    if (class_name=="") : is_class=False
    fn_mangled_name = get_mangled_name(is_class, class_name, method_name)
    print("Fn Mangled name:",fn_mangled_name)
    for func_inst in r2_dbg_flagsobj:
        temp_var = func_inst["name"]
        if ((temp_var.startswith("pdb.")) and (temp_var.find(fn_mangled_name) > 0)):
            func_list.append(temp_var)
    return func_list

def get_fn_opcode(r2_init_obj,cmd_type, fn_offset):
    """
    Generate hex dump from dissambly dump for provided function offset.
    If a function or flag has valid size then its dissambly can be generated by radare2 using cmd 'pdf @fn_offset'.
    Else get the dissambly for the function offset using cmd 'pd @fn_offset' and genarete hex dump with its end 
    bounded by where the dissambly ends with ret assembly codes like c3, c2, ca, cb. 
    """
    var_hex_dump = ""
    dump_length_bytes = 0
    func_jdump = None
    if cmd_type == "pdfj":
        print("Dissambling function ops using cmd: pdfj @" + str(fn_offset))
        func_jdump = r2_init_obj.cmdj("pdfj @"+str(fn_offset))
        dump_length_bytes = func_jdump["size"]
        for ops in func_jdump["ops"]:
            var_hex_dump+=ops["bytes"]

    elif cmd_type == "pdj":
        print("Dissambling function ops using cmd: pdj @" + str(fn_offset))
        func_jdump = r2_init_obj.cmdj("pdj @"+str(fn_offset))
        curr_byte = ""
        for list_inst in func_jdump:
            try:
                curr_byte = list_inst['bytes']
            except KeyError:
                print("Error: Key 'bytes' not found ")
                return [False, var_hex_dump, dump_length_bytes]
            if (curr_byte.startswith("c3") or curr_byte.startswith("c2") \
            or curr_byte.startswith("ca") or curr_byte.startswith("cb")):
                var_hex_dump+=curr_byte
                break
            else:
                var_hex_dump+=curr_byte
        if not (curr_byte.startswith("c3") or curr_byte.startswith("c2") \
            or curr_byte.startswith("ca") or curr_byte.startswith("cb")):
            print("Cannot find function return opp. Abort Hex dump.")
            return [False, var_hex_dump, dump_length_bytes]
        dump_length_bytes = int(len(var_hex_dump)/2)
        del(curr_byte)

    if 0:
        jfile = open(curr_dir+ cmd_type + "_dump_" + str(fn_offset) + ".json","w")
        json.dump(func_jdump,jfile)
        del(jfile)
    del(func_jdump)
    return [True,var_hex_dump,dump_length_bytes]

def init_func_debug(r2_init_obj,r2_dbg_dataobj,r2_dbg_flagsobj,class_name,method_name):
    """
    Init analysis for specific class name, function name.
    Analysis steps:
    1]  Get list of entries matching in afl json object. 
    2]  * A single entry list indiactes that a unique symbol is identified.
        * List with more then 1 entry indicates multiple symbols exists for the class name and function name 
        which may occur when function name is a substring of another function name. In such case display the 
        list to user and skip to next query.
        * List with 0 entries would indicate no symbol was found and that the function could be a nonexported symbol.
        In such case search in flags json object.
    3]  Get list of entries matching in flags json object.
    4]  * A single entry list indiactes that a unique flag is identified.
        * List with more then 1 entry indicates multiple flags exists for the class name and function name 
        which may occur when function name is a substring of another function name. In such case display the 
        list to user and skip to next query.
        * If list has 0 entries, then it inidcates that no symbol as well as no flag could be found for the particular query.
    5]  After identifying a unique symbol or flag, offest of the function is collected.
        * offset for symbol from afl datbase.
        The function dissambly for a symbol from afl json object is present at the offset indicated by the jmp instruction
        at the symbol address. Hence collect the offset of first instance in list against key'callref' for current symbol
        instance in afl json object.
        * offset for flag from flags json object.
        The function dissambly for a flag i.e for a nonexported function is indicated by the address against key'offset' 
        for current flag instance in flags json object.
    6]  Once the function offset is collected dump disaambly using appropriate pdf or pd command.
    7]  Once the assembly hex values have been collected, verify their presence in application/Dll and dump them
        into files.
    """
    func_name = None
    file_name = None
    if class_name == "":
        file_name = method_name
    else:
        file_name =  class_name + "_" + method_name
    func_offset = None
    dll_func_offset = None
    func_size = 0
    hex_dump=""
    try:
        function_list = get_func_list_from_afl(r2_dbg_dataobj,class_name,method_name)
        if len(function_list) == 1:
            func_name = function_list[0]
            print("Analysing function name: ",func_name)
            for func_inst in r2_dbg_dataobj:
                if func_inst["name"] == func_name:
                    func_offset = func_inst["callrefs"][0]["addr"]
                    break
            del(func_inst)
            [result, hex_dump, func_size] = \
                get_fn_opcode(r2_init_obj, "pdfj", func_offset)
            if not result:
                return False
        elif len(function_list) > 1:
            print ("List for class name:",class_name,"and method name:",method_name,"contains more then 1 entries.")
            print (function_list)
            return False
        
        elif len(function_list) == 0:
            function_list = get_func_list_from_flaglist(r2_dbg_flagsobj,class_name,method_name)
            if len(function_list) == 1:
                func_name = function_list[0]
                print("Analysing function name: ",func_name)
                for list_inst in r2_dbg_flagsobj:
                    if list_inst["name"] ==  func_name:
                        func_offset = list_inst["offset"]
                        func_size = list_inst["size"]
                        break
                del(list_inst)
                if func_size > 0:
                    [result, hex_dump, func_size] = \
                        get_fn_opcode(r2_init_obj, "pdfj", func_offset)
                    if not result:
                        return False
                else:
                    [result, hex_dump, func_size] = \
                        get_fn_opcode(r2_init_obj, "pdj", func_offset)
                    if not result:
                        return False
        
            elif len(function_list) > 1:
                print ("Flag List for class name:", class_name,"and method name:",method_name,"contains more then 1 entries.")
                print (function_list)
                return False
            elif len(function_list) == 0:
                print("class name:", class_name,"and method name:",method_name)
                print("Not found in function and flag list")
                return False
    except:
        print("Unexpected error:", exc_info())
        return False
    hex_dump = unhexlify(hex_dump)
    dll_func_offset = find_hex(Dll_path,hex_dump)
    if dll_func_offset < 0:
        print ("Can not find the hex dump inside the dll for class name: ",class_name," method name: ",method_name)
        return False

    #file_dump("offset_" + file_name,"dll_offset=" + str(hex(dll_func_offset))) #Dump hex data offset in dll.
    file_dump("len_" + file_name,"length=" + str(func_size)+"\n") #Dump hex data/function size.
    file_hex_dump("pyout_" + file_name,hex_dump) #Dump hex data/function disammbly.
    # file_dump("pyout_hex_" + file_name,str(hexlify(hex_dump)))
    del(hex_dump)
    print ("Hex dump successful.")
    print ("Function offset is: ",hex(func_offset))
    print ("Function Dll offset is: ",hex(dll_func_offset))
    print ("Function size: ",func_size)
    return True

def main(): 
    # flag_list = ["-d"] pass this flag as 2nd arg to open api to run debug on exe file.
    try:
        print("Loading Dll file for analysis.")
        print("         ", Dll_path)
        r2_init_obj = r2pipe.open(Dll_path) # Loading application/dll file to analyzed using radare2. Returns radare2 object.
    except:
        print("Dll file could not be opened.\nPerform following checks.\
            \n1] Correct Dll file exits in the folder where the script is present.\
            \n2] Check Dll bit version(32/64 bit) matches with bit version of python and radare2 installed on the system.")
        exit()
    print("Loading pdb file for analysis.")
    print("         ", pdb_path)
    r2_init_obj.cmd("idp " + pdb_path) # Loading appropriate pdb file for the application/dll to analyzed.
    print(r2_init_obj.cmd("aaa")) # 'Analyze all' command to start r2 object analysis.
    aflj_obj = r2_init_obj.cmdj("aflj") # Get exported function list as json string. 
    flagsj_obj = r2_init_obj.cmdj("fj") # Get all flags details as json string. Used to retrieve non-exported function details.

    if 0: # Dump afl and flags json obj into files.
        jfile = open(curr_dir+"afl_jdump.json","w")
        json.dump(aflj_obj,jfile)
        del(jfile)
        jfile = open(curr_dir+"flags_jdump.json","w")
        json.dump(flagsj_obj,jfile)
        del(jfile)

    # Load the function names to be analyzed from CSV file.
    csv_file = open(funcList_file_name,'r')
    csv_reader = list(csv.reader(csv_file, delimiter=','))
    print("Following is the function list to be analyzed.")
    for idx in range(1,len(csv_reader)):
        print(idx,"]", csv_reader[idx][0], "::", csv_reader[idx][1])
    for idx in range(1,len(csv_reader)):
        class_name = csv_reader[idx][0]
        method_name = csv_reader[idx][1]
        # Init function analysis for particular class_name::function_name.
        print("\n############################# INIT FUNC ",class_name, "::", method_name,"###########################################")
        init_func_debug(r2_init_obj,aflj_obj,flagsj_obj,class_name,method_name)
        print("############################# END FUNC ############################################")

    r2_init_obj.quit()
    del(r2_init_obj)

if __name__ == '__main__':
    main()